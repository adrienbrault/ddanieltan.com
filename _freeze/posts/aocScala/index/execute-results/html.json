{
  "hash": "2f563b30c95487e4fe8e5974699bd0fe",
  "result": {
    "markdown": "---\ntitle: \"Scala tips for Advent of Code 2022\"\ndescription: \"Twas the night before AOC\"\ndate: \"2022-11-30\"\ncategories: [scala, adventofcode]\n---\n\n# December is upon us 🎄🎅🏻🎄\n## The Advent of Code\nEvery December, I get excited about a project called the [Advent of Code (AOC)](https://adventofcode.com/). Advent of code is a free-to-join daily coding puzzle project that starts on 1 Dec and concludes on the 25th. Each day a two-part question is released on the site to test your problem-solving skills. Many programmers all around the world enjoy solving these puzzles together in a variety of programming languages. This year, being my [Year of Scala](https://www.ddanieltan.com/2022scala), it should come as no surprise that I plan on using Scala as my language of choice!\n\n::: {.column-margin}\nAmongst the many different programming languages used for AOC, I am always impressed by the mavericks who choose to use [Excel](https://detrang1301.github.io/adventofcode-2021-excel/) 🤯\n:::\n\n![Source: https://thenewstack.io/advent-of-codes-programming-puzzles-set-new-global-record/](aocLogo.jpeg)\n\n## Scala Center's Solutions for 2021\nAn amazing resource we have to prepare for this year's AOC are the examples and solutions provided by Scala Center for last year's AOC - [Scala Center Solutions to 2021 Advent of Code](https://scalacenter.github.io/scala-advent-of-code/). Here you can find a variety of solutions using solely Scala's standard library and showcasing how to best use idiomatic Scala to solve common problems. In this post, I am going to share is a summary of my tips and takeaways.\n\n# 1. Scala-cli: More time coding, less time fiddling\nAmong the many build tools available for Scala projects, my recommendation is [scala-cli](https://scala-cli.virtuslab.org/). Scala-cli is by far, the simplest tool that allows you to start solving the actual puzzles you will encounter and minimizes the time you fiddle with your project setup. You will find an easy-to-follow project structure here: https://github.com/scalacenter/scala-advent-of-code. You can install scala-cli via brew (see instructions on their website) or I typically rely on the default [Coursier](https://get-coursier.io/docs/cli-installation) setup whose default bundle of packages includes scala-cli.\n\n# 2. Case class - The swiss army knife of modelling a problem\nHow are AOC puzzles different from Leetcode? A: AOC puzzles are A LOT more verbose. Puzzles are usually described in a cute story incorporating a lot of storytelling elements which gives AOC its distinct Christmas-y flavour. But, this also means there's just so much information to parse. One of my favourite features of Scala is the `case class` because it lends itself so well to converting the information from the question into clear and concise code.\n```scala\ncase class Elf(name:String, age:Int) {\n    def isOldEnough:Boolean = { age >= 18}\n}\n\nval e1 = Elf(\"Alice\",12)\nval e2 = Elf(\"Bob\",19)\nval e3 = Elf(\"Alice\",12)\n\n// Comparison operators check for equality of data instead of the instance's memory location\ne1 == e3 // True\n\n// Case classes can hold methods just like a regular class\ne2.isOldEnough // True\n```\n\n# 3. Be explicit when using Mutability\nScala has a strong sense of pragmatism. Scala encourages immutability as a default, which makes sense as it reduces a lot of unexpected side effects. But, Scala also does not force immutability on you in every circumstance. To use a mutable data structure, you can import like so.\n```scala\nimport scala.collection.mutable\n\n// A mutable map with key (x,y) --> value\nvar map = mutable.Map[Tuple2[Int,Int], Int]()\n\n// Initialising the map\nmap((0,0)) = 0\nmap((0,1)) = 0\nmap((1,0)) = 0\nmap // HashMap((0, 0) -> 0, (1, 0) -> 0, (0, 1) -> 0)\n\n// Updating values in the Map\nmap((0,0)) += 1\nmap // HashMap((0, 0) -> 1, (1, 0) -> 0, (0, 1) -> 0)\n```\nKeeping track of a map of (x,y) coordinates that correspond to a value that can change as the problem progresses is a rather common problem you will encounter. While I am sure you can still solve this problem using immutable data structures, I am glad that an option to use mutability exists. I also enjoy explicitly declaring which data structures are mutable because it reminds me to keep mutability to a minimum.\n\n# 4. Use Recursion in place of repetition\nIn Scala, the recommendation is to use recursion in places where we need repetition. However, refactoring while loops to a recursive function used to be unintuitive for me, until I came across [@Kit Langton](https://www.youtube.com/@TheAtomicmoose)'s video.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/E8rwsxn1iTM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\nOnce you get a hang of recursion, a lot of solutions that require you to repeat actions while waiting for a condition get a lot simpler to understand. A classic example is a search algorithm which comes up fairly often in AOC.\n\n```scala\ncase class Point(row:Int, col:Int)\n\n@scala.annotation.tailrec\ndef search(\n    visited: Set[Point],\n    toVisit: mutable.Queue[Point],\n    qualifiedPoints: Set[Point]\n) = {\n    if toVisit.isEmpty then qualifiedPoints\n    else {\n        val nextPoint = toVisit.dequeue\n        val newPointsToVisit = ...\n\n        search(\n            visited ++ Set(nextPoint),\n            toVisit ++ newPointsToVisit,\n            qualifiedPoints ++ Set(nextPoint))\n    }\n}\n```\n# 5. Pattern matching - Exhaustively check for all paths your code can take\nPattern matching in Scala is incredibly expressive and I can't do justice to this amazing feature in a single paragraph. If you are new to Scala, be sure to learn the various ways you can pattern match from the [Scala official website](https://docs.scala-lang.org/tour/pattern-matching.html). Specific to the puzzles in AOC, 1 thing I love about pattern matching is that the compiler will exhaustively check for every path my code execution can take and alert me if I missed something (which happens rather often).\n![Compiler checking for exhaustiveness](diagnostic.png)\n\n\n# 6. Use Try for elegant error handling\nIf you have many actions to run and some of which might throw an error, you can handle this situation elegantly by wrapping the actions in a `Try`. This converts the output to either a `Success` or `Failure` type that you can simply filter on.\n```scala\nval actions = Seq(\n    Try { 1 + 1 },\n    Try { 1 / 0 }\n) // List(Success(value = 2), Failure(exception = java.lang.ArithmeticException: / by zero))\n\nval successfulActions = actions.filter(_.isSuccess) // List(Success(value = 2))\n```\n\n# Conclusion\nAnd, there you go! Hope these were useful tips and that I got you excited to try them out for 2022's Advent of Code. Happy coding!\n\n## Appendix {.appendix}\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\nLast updated: 02 March 23\n```\n:::\n:::\n\n\n<blockquote>\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\nSomewhere, something incredible is waiting to be known -- Carl Sagan\n```\n:::\n:::\n\n\n</blockquote>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}