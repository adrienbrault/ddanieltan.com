{
  "hash": "0127382e94cdb832e57212fc7844ed58",
  "result": {
    "markdown": "---\ntitle: \"Explainers: Inverse Transform Theorem\"\ndescription: \"A #SomE2 submission\"\ndate: \"2022-08-08\"\n#image: \"image.jpg\"\ncategories: [explainers, R, simulation]\n---\n\n:::{.callout-note}\nThis post is my submission to 2022's Summer of Math Exposition 2 (SoME2), a competition encouraging people all around the world to create expository content on their favourite math topics during the summer. \n\nYou can learn more about #SoME2 from [Grant Sanderson's(3B1B) video](https://youtu.be/hZuYICAEN9Y).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nset.seed(sum(utf8ToInt(\"SoME2\")))\n```\n:::\n\n# Worlds at our fingertips\nModern day computers are pretty amazing simulation machines.\n\nHere's an example. Say that I am a [Bottle Flipping](https://www.wikihow.com/Do-the-Water-Bottle-Flipping-Challenge) enthusiast and I am eager to simulate 100 bottle flips. TheAnd, if you could not bring yourself to actually flip a bottle 100 times, we could instead can instruct the computer to provide 100 random variates generated from a binomial distribution.\n\n::: {.cell}\n\n```{.r .cell-code}\ntotalFlips = 100\nprob = 0.2 # Took me 5 tries to flip the bottle once\nrbinom(totalFlips, 1, prob) # 1 represents a successful flip\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 1 0 1 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0\n [38] 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0\n [75] 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\n```\n:::\n:::\n\n:::{.column-margin}\nYes, ðŸ™„ I know bottle flipping was a trend way back in [2016](https://www.quora.com/What-are-the-origins-of-bottle-flipping-How-did-its-popularity-spread). I needed a success/failure example and it was either this of \"coin flips\" which I could not bring myself to use\n:::\n\nOr, say I'm a sports fan and my football team scores an average of 1 goal per game. I could simulate the goals scored over 100 games by calling for 100 random variates from a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution).\n\n::: {.cell}\n\n```{.r .cell-code}\ntotalGames=100\navgGoalsPerGame = 1\nrpois(totalGames,avgGoalsPerGame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 0 1 2 1 2 2 0 0 1 2 2 0 1 0 1 3 2 2 1 1 2 1 1 1 1 0 4 3 1 0 0 0 2 1 0 1 0\n [38] 0 2 2 1 0 3 1 3 0 0 0 1 1 2 2 1 2 2 0 2 2 0 0 0 1 0 0 2 1 1 2 2 0 3 0 0 0\n [75] 0 0 0 1 1 2 1 2 0 1 3 1 2 0 0 2 2 0 2 1 0 0 2 2 1 1\n```\n:::\n:::\n\n\nFrom models using a single distribution to ones using complex combinations, the ability to generate random variates to simulate almost any scenario we can think of is stunning. \n\n# How random variates are generated\nBut, how do computers even produce these random variates? Surely, there can't be a specialised function for every one of the infinite distributions! It turns out that computers have a very simple solution in the form of two ingredients - a pseudorandom uniform generator and the inverse transform theorem. \n\nA pseudoranom uniform generator is an algorithm that produces random variates from a $Unif~(0,1)$ distribution, producing random numbers between 0 and 1. Essentially, we rely on this generator to capture the \"randomness\" quality.\n\n:::{.column-margin}\nThere is an entire family of pseudorandom number generators, and I'll \n:::\n\n\nThere's an How do computers provide random variates for these multitude of distributions? Certainly, we can't expect a dedicated pseudorandom algorithm for every distribution imaginable. Well, it turns out that the rosetta stone of random variate generation starts from a pseudorandom generator for the uniform distribution.\n\nThe Uniform distribution is a distribution where \n\n:::{.column-margin}\nWe will talk more about the uniform distribution in a future post.\n:::\n\n# Inverse Transform Theorem\n\nShow Nasty derivation\n\nHow can something so simple be universally applied to every possible distribution?\n\n# Visual connection\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}